def _log_execution_step(self, rule_dict: Dict[str, Any], action: str, 
                       input_data: Any = None, output_data: Any = None,
                       error_message: str = None, message_type: str = "INFO",
                       action_status: str = "SUCCESS") -> None:
        """Log execution step to database"""
        try:
            # Prepare data for logging
            rule_id = rule_dict.get('rule_id', '')
            rule_name = rule_dict.get('rule_name', '')
            step_id = rule_dict.get('rule_step_number', '')
            
            # Get existing fields
            intent_type = self.current_context.get('intent_type', rule_dict.get('intent_type', ''))
            mtn_data = self.current_context.get('mtn_list')
            mtn_log_value = str(mtn_data) if mtn_data else ''

            # --- IMPROVED EXTRACTION LOGIC START ---
            channel_id = ''
            activation_status = ''
            source_type_code = ''
            source_type_val = ''

            # 1. Search through ALL API results in context to find the data
            for key, value in self.current_context.items():
                # Only look at API results
                if key.startswith('api_result_') and isinstance(value, dict):
                    data = value.get('response_data', {})
                    if not data: continue

                    # A. Extract Channel ID (Look inside orderDetails)
                    if not channel_id and 'orderDetails' in data and data['orderDetails']:
                        channel_id = data['orderDetails'].get('channel', '')

                    # B. Extract Activation Status 
                    # Priority 1: Check 'activationDetailsList'
                    if not activation_status and 'activationDetailsList' in data and isinstance(data['activationDetailsList'], list):
                        if len(data['activationDetailsList']) > 0:
                            activation_status = data['activationDetailsList'][0].get('activationStatus', '')
                    
                    # Priority 2: Check inside 'orderDetails' (Fallback found in your logs)
                    if not activation_status and 'orderDetails' in data and data['orderDetails']:
                        activation_status = data['orderDetails'].get('activationStatus', '')

                    # C. Extract Source Type (from Pending Orders)
                    if not source_type_code and 'pendingOrders' in data and isinstance(data['pendingOrders'], list):
                        if len(data['pendingOrders']) > 0:
                            source_type_code = data['pendingOrders'][0].get('sourceTypeCode', '')
                            source_type_val = data['pendingOrders'][0].get('sourceTypeVal', '')
            
            # --- IMPROVED EXTRACTION LOGIC END ---

            # --- VERIFICATION DEBUG PRINT ---
            print(f"\nüß™ VERIFICATION DEBUG:")
            print(f"   CHANNEL_ID:       {channel_id}")
            print(f"   ACTIVATION_STATUS: {activation_status}")
            print(f"   SOURCE_TYPE_CODE:  {source_type_code}")
            print(f"   SOURCE_TYPE_VAL:   {source_type_val}")
            print("-" * 30)

            # Convert complex data to JSON strings
            input_json = json.dumps(input_data, default=str) if input_data else None
            output_json = json.dumps(output_data, default=str) if output_data else None

            # Generate LOG_ID
            log_id = int(datetime.now().strftime('%Y%m%d%H%M%S%f')[:-3]) + random.randint(1, 999)

            # SQL QUERY
            insert_sql = """
                INSERT INTO CXP_OPS_MONITORING.CXP_STORE_SUPPORT_EXECUTION_LOG_NP (
                    LOG_ID, RULE_ID, SESSION_ID, RULE_NAME, ORDER_NUMBER, 
                    LOCATION_CODE, STEP_ID, STEP_NAME, ACTION, INPUT_DATA, 
                    OUTPUT_DATA, ERROR_MESSAGE, MESSAGE_TYPE, ACTION_STATUS, 
                    INTENT_TYPE, MTN, 
                    CHANNEL_ID, ACTIVATION_STATUS, SOURCE_TYPE_CODE, SOURCE_TYPE_VAL,
                    CREATED_DATE
                ) VALUES (
                    :log_id, :rule_id, :session_id, :rule_name, :order_number,
                    :location_code, :step_id, :step_name, :action, :input_data,
                    :output_data, :error_message, :message_type, :action_status, 
                    :intent_type, :mtn, 
                    :channel_id, :activation_status, :source_type_code, :source_type_val,
                    SYSTIMESTAMP
                )
            """

            self.cursor.execute(insert_sql, {
                'log_id': log_id,
                'rule_id': rule_id,
                'session_id': self.session_id,
                'rule_name': rule_name,
                'order_number': self.current_context.get('order_number', ''),
                'location_code': self.current_context.get('location_code', ''),
                'step_id': str(step_id),
                'step_name': rule_name,
                'action': action,
                'input_data': input_json,
                'output_data': output_json,
                'error_message': error_message,
                'message_type': message_type,
                'action_status': action_status,
                'intent_type': intent_type,
                'mtn': mtn_log_value,
                'channel_id': str(channel_id),
                'activation_status': str(activation_status),
                'source_type_code': str(source_type_code),
                'source_type_val': str(source_type_val)
            })

            self.connection.commit()

            print(f"üìù LOGGED: {action} for {rule_name} (Session: {self.session_id})")

        except Exception as e:
            print(f"‚ùå Logging error: {str(e)}")
            pass
