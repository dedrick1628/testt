ALTER TABLE CXP_OPS_MONITORING.CXP_STORE_SUPPORT_EXECUTION_LOG_NP 
ADD (
    CHANNEL_ID VARCHAR2(100), 
    ACTIVATION_STATUS VARCHAR2(500), 
    SOURCE_TYPE_CODE VARCHAR2(100), 
    SOURCE_TYPE_VAL VARCHAR2(100)
);


def _log_execution_step(self, rule_dict: Dict[str, Any], action: str, 
                       input_data: Any = None, output_data: Any = None,
                       error_message: str = None, message_type: str = "INFO",
                       action_status: str = "SUCCESS") -> None:
        """Log execution step to database"""
        try:
            # Prepare data for logging
            rule_id = rule_dict.get('rule_id', '')
            rule_name = rule_dict.get('rule_name', '')
            step_id = rule_dict.get('rule_step_number', '')
            
            # Get existing fields
            intent_type = self.current_context.get('intent_type', rule_dict.get('intent_type', ''))
            mtn_data = self.current_context.get('mtn_list')
            mtn_log_value = str(mtn_data) if mtn_data else ''

            # --- NEW EXTRACTION LOGIC START ---
            channel_id = ''
            activation_status = ''
            source_type_code = ''
            source_type_val = ''

            # 1. Extract Channel ID (Try direct dict first, then recursive search)
            if self.current_context.get('orderDetailsSingleDict'):
                channel_id = self.current_context['orderDetailsSingleDict'].get('channel', '')
            else:
                # Fallback: Search for 'channel' anywhere in context
                channel_id = self.find_key_recursively(self.current_context, 'channel') or ''

            # 2. Extract Source Type Code/Val (from Pending Orders)
            # Try the processed list first (most reliable)
            pending_orders = self.current_context.get('processedPendingOrderDetails')
            if pending_orders and isinstance(pending_orders, list) and len(pending_orders) > 0:
                source_type_code = pending_orders[0].get('sourceTypeCode', '')
                source_type_val = pending_orders[0].get('sourceTypeVal', '')
            else:
                # Fallback: Search recursively
                source_type_code = self.find_key_recursively(self.current_context, 'sourceTypeCode') or ''
                source_type_val = self.find_key_recursively(self.current_context, 'sourceTypeVal') or ''

            # 3. Extract Activation Status (Only if Activation flow)
            # We look for the list of details
            act_list = self.current_context.get('activationDetailsList') or self.find_key_recursively(self.current_context, 'activationDetailsList')
            if act_list and isinstance(act_list, list) and len(act_list) > 0:
                # Grab the status from the first item
                activation_status = act_list[0].get('activationStatus', '')
            # --- NEW EXTRACTION LOGIC END ---

            # Convert complex data to JSON strings
            input_json = json.dumps(input_data, default=str) if input_data else None
            output_json = json.dumps(output_data, default=str) if output_data else None

            # Generate LOG_ID using timestamp + random number
            log_id = int(datetime.now().strftime('%Y%m%d%H%M%S%f')[:-3]) + random.randint(1, 999)

            # UPDATED SQL QUERY WITH 4 NEW COLUMNS
            insert_sql = """
                INSERT INTO CXP_OPS_MONITORING.CXP_STORE_SUPPORT_EXECUTION_LOG_NP (
                    LOG_ID, RULE_ID, SESSION_ID, RULE_NAME, ORDER_NUMBER, 
                    LOCATION_CODE, STEP_ID, STEP_NAME, ACTION, INPUT_DATA, 
                    OUTPUT_DATA, ERROR_MESSAGE, MESSAGE_TYPE, ACTION_STATUS, 
                    INTENT_TYPE, MTN, 
                    CHANNEL_ID, ACTIVATION_STATUS, SOURCE_TYPE_CODE, SOURCE_TYPE_VAL,
                    CREATED_DATE
                ) VALUES (
                    :log_id, :rule_id, :session_id, :rule_name, :order_number,
                    :location_code, :step_id, :step_name, :action, :input_data,
                    :output_data, :error_message, :message_type, :action_status, 
                    :intent_type, :mtn, 
                    :channel_id, :activation_status, :source_type_code, :source_type_val,
                    SYSTIMESTAMP
                )
            """

            self.cursor.execute(insert_sql, {
                'log_id': log_id,
                'rule_id': rule_id,
                'session_id': self.session_id,
                'rule_name': rule_name,
                'order_number': self.current_context.get('order_number', ''),
                'location_code': self.current_context.get('location_code', ''),
                'step_id': str(step_id),
                'step_name': rule_name,
                'action': action,
                'input_data': input_json,
                'output_data': output_json,
                'error_message': error_message,
                'message_type': message_type,
                'action_status': action_status,
                'intent_type': intent_type,
                'mtn': mtn_log_value,
                # New Fields
                'channel_id': str(channel_id),
                'activation_status': str(activation_status),
                'source_type_code': str(source_type_code),
                'source_type_val': str(source_type_val)
            })

            self.connection.commit()

            print(f"üìù LOGGED: {action} for {rule_name} (Session: {self.session_id})")

        except Exception as e:
            print(f"‚ùå Logging error: {str(e)}")
            # Don't fail the main process due to logging issues
            pass
